#!/usr/bin/env python

import argparse
import datetime
import re
import pickle
import sys

import pandas as pd
import pandas.io.data
from   pandas import Series, DataFrame

sys.path.append(".")
import analysis


##############################################################
# Main loop. Iterate through each scripts and collect data
##############################################################
def main_loop(ticker_dict, params):
    assert(type(ticker_dict) == dict)
    assert(type(params) == analysis.parameters)

    analysis_obj = analysis.analysis_class(params)

    for ticker in ticker_dict.keys():
        try:
            analysis_obj.init_stock_data(ticker)
        except IOError:
            if verbose:
                print "yahoo doesn't identify the ticker symbol {}" . format(ticker)
            continue
        except KeyError:
            if verbose:
                print "KeyError received on ticker symbol {}" . format(ticker)
            continue

        ## Check for average trade volumes for previous 100 days
        if volume_check and pd.rolling_mean(stock_volume_data, 100)[-1] < trade_min:
            if verbose:
                print "100 day median trade volume for {} is below {}" . format(ticker, trade_min)
            continue

        ## Check for price range
        if price_check and ((stock_close_data[-1] < pmin) or (stock_close_data[-1] > pmax)):
            if verbose:
                print "{} has latest closing price {}, hence is not in the defined price range" . format(ticker, stock_close_data[-1])
            continue

        ## Process the data
        process_stock_graph_series(stock_data, ticker_dict[ticker])

    # if plotting is enabled now is the time to display the graphs
    if plot_yes:
        analysis.show()

##########################################################################
# Process and plot the stock movement along with some moving averages
##########################################################################
def process_stock_graph_series(obj, label):
    assert(type(obj) == pd.core.frame.DataFrame)

    mov_avg_h         = {};
    local_trend       = 99;
    close_data        = obj["Close"]
    vol_data          = obj["Volume"]
    adj_close_data    = obj["Adj Close"]

    # Populate all rolling means in a hash
    for dindex in mova_days_dict.keys():
        rolling_mean = pd.rolling_mean(adj_close_data, mova_days_dict[dindex])
        mov_avg_h[mova_days_dict[dindex]] = rolling_mean

    # Calculate local trend based on global parameters specified
    if mov_avg_h[max(compr_ravg_tup)][-1] < mov_avg_h[min(compr_ravg_tup)][-1]:
        local_trend = 1
    elif mov_avg_h[max(compr_ravg_tup)][-1] > mov_avg_h[min(compr_ravg_tup)][-1]:
        local_trend = 2
    else:
        local_trend = 99

    # Do a trend check
    # If the speicifed trend doesn't match with that specified as control parameter
    # return
    if ticker_trend != 0:
        if ticker_trend == local_trend:
            print "-------- {} shows {} trend" . format(label, ticker_trend_tostr[local_trend])
        else:
            return;
    else:
        print "-------- {} shows {} trend" . format(label, ticker_trend_tostr[local_trend])
    
    # plotting not allowed
    if not plot_yes:
        return;

    title = "Closing Price trend [with ";

    plot_obj = analysis.plots_class(label=label)

    # Plot closing price trend along with moving averages
    #
    plot_obj.plot_pandas_series(adj_close_data, ratio=2)
    # Plot rolling means        
    for dindex in mova_days_dict.keys():
        rolling_mean = pd.rolling_mean(adj_close_data, mova_days_dict[dindex])
        plot_obj.plot_pandas_series(rolling_mean, frame=0)
    # Plot volume trend
    plot_obj.bar_pandas_series(vol_data, label="volume trend", ratio=1)


############################################
# main
############################################
if __name__ == '__main__':
    # define parameters instance
    params           = analysis.parameters()

    ticker_dict_n    = {}
    ticker_dict_t    = {}
    regex_m          = re.compile(r'([\w\.\-]+)[ \t\r\f\v]+"([ \w\W\t\r\f\v\-]+)"')       # match for valid line
    regex_h          = re.compile(r'(\w+)-\w+.NS')          # match for date format on command line
    regex_c          = re.compile(r'^#')                    # Match format for comment

    parser           = argparse.ArgumentParser()
    parser.add_argument("dfile", help="data description file generated by stock_list_pull script.", type=str)

    parser.add_argument("--vmin",     help="minimum volume limit",                      type=int)
    parser.add_argument("--pmin",     help="minimum price limit",                       type=int)
    parser.add_argument("--pmax",     help="maximum price limit",                       type=int)
    parser.add_argument("--tstart",   help="start time (day)",                          type=str)
    parser.add_argument("--tend",     help="end time (day)",                            type=str)
    parser.add_argument("--pfile",    help="pickle file",                               type=str)
    parser.add_argument("--trend",    help="ticker trend (0=all, 1=up, 2=down)",        type=int)
    parser.add_argument("--regex",    help="perl compatible regex for scrip search",    type=str)
    parser.add_argument("--plot",     help="plot graphs",                               action='store_true')
    parser.add_argument("--verbose",  help="verbose option",                            action='store_true')

    args             = parser.parse_args()

    # open description file
    f = open(args.dfile, "r");
    for line in f:
        # This means we encountered a comment
        if regex_c.match(line):
            continue

        res = regex_m.search(line)
        if res:
            ticker_dict_n[res.groups()[0]] = res.groups()[1]
        else:
            # This line is not recognised
            continue

    # check if pickle file was provided & redirect function pointer for
    # geting ticker values
    if args.pfile:
        params.set_input_pickle_file(args.pfile)

    # Check price limits
    if args.pmin:
        params.set_price_min(args.pmin)
    if args.pmax:
        params.set_price_max(args.pmax)

    # check trade limit
    if args.vmin:
        params.set_volume_min(args.vmin)

    # check time
    if args.tstart:
        params.set_date_start(args.tstart)
    if args.tend:
        params.set_date_end(args.tend)

    # trend
    if args.trend:
        params.ticker_trend = args.trend

    # plot var
    if args.plot:
        params.plot_yes     = True

    # verbose
    if args.verbose:
        params.verbose      = True

    ##########
    # hack required for script names with -EQ.NS subscript (for eg. PCJEWELLERS-EQ.NS).
    # They don't work with pandas yahoo api at this time.
    # Hackish solution is to derive the corresponding BSE name, which doesn't contain -EQ
    # substring.
    for index in ticker_dict_n.keys():
        name_new  = index
        res       = regex_h.search(index)
        if res:
            name_new = res.groups()[0] + ".BO"
        ticker_dict_t[name_new] = ticker_dict_n[index]

    # Clear the original list
    ticker_dict_n = {}

    # Check for the any passed regex
    if args.regex:
        regex_c      = re.compile('{}' . format(args.regex))
        for index in ticker_dict_t.keys():
            if regex_c.match(index) or regex_c.match(ticker_dict_t[index]):
                ticker_dict_n[index] = ticker_dict_t[index]
    else:
        ticker_dict_n = ticker_dict_t


    print "............... stock analysis parameters ...................."
    print "pandas version                                = {}" . format(pd.__version__)
    print "configured ticker trend                       = {}" . format(ticker_trend_tostr[ticker_trend])
    print "configured moving averages                    = {}" . format(mova_days_dict.keys())
    print "configured moving averages for trend analysis = {}" . format(str((pmin, pmax)))
    print "configured duration start time                = {}" . format(starttime)
    print "configured duration end time                  = {}" . format(endtime)
    print "configured plotting allowed                   = {}" . format(plot_yes)
    print ".............................................................."
    print "\n"

    main_loop(ticker_dict_n, params)

    # Dump global data structure to pickle file
    if pickle_file_passed == 0:
        pickle.dump(glb_data_struct, open(args.dfile + ".pkl", "wb"))
